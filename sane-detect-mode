#!/usr/bin/env bash
# sane-detect-mode - Detect mode (bash vs raw) in a tmux pane
# Usage: sane-detect-mode SESSION[:WINDOW.PANE]
# Examples:
#   sane-detect-mode tues              # Active pane
#   sane-detect-mode tues:0.0          # Specific pane
#   sane-detect-mode tues:0            # Window 0, active pane
#
# Returns JSON with:
#   - mode: "bash" or "raw"
#   - shell: detected shell type (bash, zsh, sh, python, node, perl, etc.)
#   - capabilities: array of supported operations
#   - supports_structured_prompt: boolean

set -euo pipefail

TARGET="${1:-}"

if [[ -z "$TARGET" ]]; then
    echo "Usage: sane-detect-mode SESSION[:WINDOW.PANE]" >&2
    exit 1
fi

# Check if session exists (extract session name from target)
SESSION=$(echo "$TARGET" | cut -d: -f1)
if ! tmux has-session -t "$SESSION" 2>/dev/null; then
    echo "Error: Session '$SESSION' does not exist" >&2
    exit 1
fi

# Validate pane target if specified (SESSION:WINDOW.PANE format)
if [[ "$TARGET" == *":"* ]]; then
    PANE_SPEC=$(echo "$TARGET" | cut -d: -f2)
    # Validate format: should be WINDOW.PANE or WINDOW
    if ! echo "$PANE_SPEC" | grep -E '^[0-9]+(\.[0-9]+)?$' > /dev/null; then
        echo "Error: Invalid pane specification '$PANE_SPEC'. Use format WINDOW or WINDOW.PANE" >&2
        exit 1
    fi
    if ! tmux list-panes -t "$TARGET" > /dev/null 2>&1; then
        echo "Error: Pane '$TARGET' does not exist" >&2
        exit 1
    fi
else
    # Use session shorthand (active pane)
    TARGET="$SESSION"
fi

# Use unique markers to reliably extract command output
MARKER="SANE_DETECT_MODE_$$_$(date +%s)"

# Send detection commands with markers
# We'll check for: shell type, prompt, capabilities
tmux send-keys -t "$TARGET" "echo '${MARKER}_START'" Enter
sleep 0.3
tmux send-keys -t "$TARGET" "echo \"\$SHELL\" | xargs basename" Enter
sleep 0.3
tmux send-keys -t "$TARGET" "ps -o comm= -p \$\$" Enter
sleep 0.3
tmux send-keys -t "$TARGET" "echo '${MARKER}_END'" Enter
sleep 0.5

# Capture output
FULL_OUTPUT=$(tmux capture-pane -t "$TARGET" -p)

# Extract lines between markers, skip command lines (those with $)
OUTPUT=$(echo "$FULL_OUTPUT" | sed -n "/${MARKER}_START/,/${MARKER}_END/p" | grep -v "${MARKER}" | grep -v '\$' | grep -v '^$')

# Parse output - get shell information
# Line 1: Shell from $SHELL variable
# Line 2: Process name from ps
SHELL_NAME=$(echo "$OUTPUT" | sed -n '1p' | tr -d '\r\n' | xargs)
PROCESS_NAME=$(echo "$OUTPUT" | sed -n '2p' | tr -d '\r\n' | xargs)

# Determine shell type and mode
MODE="bash"
SHELL_TYPE="$SHELL_NAME"

# If SHELL_NAME is empty, use process name
if [[ -z "$SHELL_NAME" ]]; then
    SHELL_TYPE="$PROCESS_NAME"
fi

# Default to bash if we can't determine
if [[ -z "$SHELL_TYPE" ]]; then
    SHELL_TYPE="bash"
fi

# Detect if we're in a non-bash environment
case "$SHELL_TYPE" in
    bash|sh|dash|zsh|ksh|ash)
        MODE="bash"
        ;;
    python*|node*|perl*|ruby*|php*|java*|scala*|clojure*|irb*|pry*|groovy*)
        MODE="raw"
        ;;
    *)
        # Check if output contains REPL prompts (>>>, >, DB<, irb, pry)
        if echo "$FULL_OUTPUT" | grep -E '(>>>|^>|DB<|irb\(|pry\(|sql>)' > /dev/null 2>&1; then
            MODE="raw"
        else
            # Default to bash for unknown shells if they accept bash
            MODE="bash"
        fi
        ;;
esac

# Build capabilities list
CAPABILITIES=()
if [[ "$MODE" == "bash" ]]; then
    CAPABILITIES=("run_command" "create_file" "read_file" "validate_bash" "validate_json" "setup_prompt" "capture_output")
    SUPPORTS_PROMPT=true
else
    CAPABILITIES=("send_keys" "read_screen")
    SUPPORTS_PROMPT=false
fi

# Build JSON capabilities array
CAPS_JSON=$(printf '%s\n' "${CAPABILITIES[@]}" | jq -R . | jq -s .)

# Build the JSON response
if [[ "$MODE" == "bash" ]]; then
    JSON="{\"mode\":\"$MODE\",\"shell\":\"$SHELL_TYPE\",\"capabilities\":$CAPS_JSON,\"supports_structured_prompt\":$SUPPORTS_PROMPT,\"bash_specific\":{\"command_name\":\"$PROCESS_NAME\"}}"
else
    JSON="{\"mode\":\"$MODE\",\"shell\":\"$SHELL_TYPE\",\"capabilities\":$CAPS_JSON,\"supports_structured_prompt\":$SUPPORTS_PROMPT}"
fi

# Output JSON
echo "$JSON"
